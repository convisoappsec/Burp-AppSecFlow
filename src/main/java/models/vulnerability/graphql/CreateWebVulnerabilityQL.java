package models.vulnerability.graphql;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import models.graphql.GraphQLMutation;
import models.vulnerability.Evidence;
import models.vulnerability.Vulnerability;
import org.apache.http.HttpEntity;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import utilities.Util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class CreateWebVulnerabilityQL extends GraphQLMutation {

    private Vulnerability vulnerability;
    private String archivesMap;

    public CreateWebVulnerabilityQL(Vulnerability vulnerability) {
        this.vulnerability = vulnerability;
    }

    private String queryCreateWebVulnerabilityNotInvaded = "{\"query\": \"mutation($vulnerabilityArchives: [Upload!]!){" +
            "createWebVulnerability(input: {" +
            "analysisId: %1$d, " +
            "vulnerabilityTemplateId: %2$d, " +
            "impact: \\\"%3$s\\\", " +
            "probability: \\\"%4$s\\\", " +
            "description: \\\"%5$s\\\", " +
            "impactResume: \\\"%6$s\\\", " +
            "webProtocol: \\\"%7$s\\\", " +
            "webMethod: \\\"%8$s\\\", " +
            "webUrl: \\\"%9$s\\\", " +
            "webParameters: \\\"%10$s\\\", " +
            "webSteps: \\\"%11$s\\\", " +
            "webRequest: \\\"%12$s\\\", " +
            "webResponse: \\\"%13$s\\\", " +
            "invaded: false, " +
            "vulnerabilityArchives: $vulnerabilityArchives })" +
            "{ errors vulnerability { id }}}\"," +
            "\"variables\":{\"vulnerabilityArchives\": [%14$s]}," +
            "\"operationName\":null}";

    private String queryCreateWebVulnerabilityInvaded = "{\"query\": \"mutation($vulnerabilityArchives: [Upload!]!){" +
            "createWebVulnerability(input: {" +
            "analysisId: %1$d, " +
            "vulnerabilityTemplateId: %2$d, " +
            "impact: \\\"%3$s\\\", " +
            "probability: \\\"%4$s\\\", " +
            "description: \\\"%5$s\\\", " +
            "impactResume: \\\"%6$s\\\", " +
            "webProtocol: \\\"%7$s\\\", " +
            "webMethod: \\\"%8$s\\\", " +
            "webUrl: \\\"%9$s\\\", " +
            "webParameters: \\\"%10$s\\\", " +
            "webSteps: \\\"%11$s\\\", " +
            "webRequest: \\\"%12$s\\\", " +
            "webResponse: \\\"%13$s\\\", " +
            "invaded: true, " +
            "invadedDescription: \\\"%14$s\\\", " +
            "vulnerabilityArchives: $vulnerabilityArchives })" +
            "{ errors vulnerability { id }}}\"," +
            "\"variables\":{\"vulnerabilityArchives\": [%15$s]}," +
            "\"operationName\":null}";


    private void prepareQuery() {
        if (this.vulnerability.getInvaded()) {
            this.setQueryCreateWebVulnerabilityInvaded();
        } else {
            this.setQueryCreateWebVulnerabilityNotInvaded();
        }
    }

    private void prepareArchivesMap() {
        HashMap<String, ArrayList<String>> mapArchives = new HashMap<>();
        for (int i = 0; i < this.vulnerability.getVulnerabilityArchives().size(); i++) {
            ArrayList<String> neededEncapsulation = new ArrayList<>();
            neededEncapsulation.add("variables.vulnerabilityArchives." + i);
            mapArchives.put(String.valueOf(i), neededEncapsulation);
        }

        this.archivesMap = new Gson().toJson(mapArchives);
    }

    private void setQueryCreateWebVulnerabilityNotInvaded() {
        this.query = String.format(this.queryCreateWebVulnerabilityNotInvaded,
                this.vulnerability.getAnalysisId(),
                this.vulnerability.getVulnerabilityTemplateId(),
                this.vulnerability.getImpact(),
                this.vulnerability.getProbability(),
                Util.jsonSafeString(this.vulnerability.getDescription()),
                Util.jsonSafeString(this.vulnerability.getImpactResume()),
                this.vulnerability.getWebProtocol(),
                this.vulnerability.getWebMethod(),
                this.vulnerability.getWebUrl(),
                this.vulnerability.getWebParameters(),
                Util.jsonSafeString(this.vulnerability.getWebSteps()),
                this.vulnerability.getWebRequest(),
                this.vulnerability.getWebResponse(),
                this.vulnerability.getNullByEvidencesListSize());
    }

    private void setQueryCreateWebVulnerabilityInvaded() {
        this.query = String.format(this.queryCreateWebVulnerabilityInvaded,
                this.vulnerability.getAnalysisId(),
                this.vulnerability.getVulnerabilityTemplateId(),
                this.vulnerability.getImpact(),
                this.vulnerability.getProbability(),
                Util.jsonSafeString(this.vulnerability.getDescription()),
                Util.jsonSafeString(this.vulnerability.getImpactResume()),
                this.vulnerability.getWebProtocol(),
                this.vulnerability.getWebMethod(),
                this.vulnerability.getWebUrl(),
                this.vulnerability.getWebParameters(),
                Util.jsonSafeString(this.vulnerability.getWebSteps()),
                this.vulnerability.getWebRequest(),
                this.vulnerability.getWebResponse(),
                Util.jsonSafeString(this.vulnerability.getInvadedEnvironmentDescription()),
                this.vulnerability.getNullByEvidencesListSize());
    }

    public HttpEntity getHttpEntity() throws FileNotFoundException {
        this.prepareQuery();
        this.prepareArchivesMap();

        MultipartEntityBuilder multipartEntityBuilder = MultipartEntityBuilder.create();
        multipartEntityBuilder.addTextBody("operations", this.query);
        multipartEntityBuilder.addTextBody("map", this.archivesMap);


        for (int i = 0; i < vulnerability.getVulnerabilityArchives().size(); i++) {
            Evidence e = vulnerability.getVulnerabilityArchives().get(i);
            File file = new File(e.getPath());
            multipartEntityBuilder.addBinaryBody(String.valueOf(i), new FileInputStream(file), ContentType.APPLICATION_OCTET_STREAM, Util.removeSpecialCharacters(e.getName()));
        }

        return multipartEntityBuilder.build();
    }


}
